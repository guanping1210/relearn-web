// @ts-nocheck
/**
 * 垃圾回收机制：js在创建变量时自动进行了分配内存，在使用完这些变量之后，会有一个内存释放过程，这个过程就是垃圾回收
 * 
 * 如果把内存管理权限给开发者的话，可能会出现混乱，啥时候释放变量，为变量分配内存，就搞不准了
 * 所以js帮我们自动回收了
 * 
 * 垃圾回收机制主要依赖于引用的概念，在内存管理的环境中，一个对象访问了另一个对象，就叫做一个对象引用另一个对象，
 * 不仅是对象的引用，还有作用域的引用，例如闭包
 * 
 * 1、引用计数算法，是最初级的垃圾回收算法
 * 2、标记-清除算法，是为了解决引用计数的循环引用而出现的（当变量进入执行环境时被标记为"进入环境"，执行完毕离开环境标记为"离开环境"）
 * 3、V8的 分代收集 回收机制
 */
var n = 123 // 给数值变量分配内存
var s = 'hello' // 给字符串变量分配内存
var o = { // 给对象及其包含的值分配内存
    a: 1,
    b: null
}

// 1、引用计数算法 --> 实际是通过在对象头中分配一个空间来保存该对象被引用的次数，如果被其他对象引用，计数加一，删除该对象的引用，计数减一
//    当该对象的引用计数为0时，该对象就会被回收
// 缺点：循环引用，永远无法删除
function foo() {
    var obj = { a: 1 }
    var a2 = obj.a
    obj.a = a2
}

foo() // 内部的obj.a被a2引用着，a2又被obj.a引用着，这个就无法清除了


// 2、标记-清除算法 --> 设定一个根对象，垃圾回收器会定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象....., 
//    从根开始，垃圾回收器会找到所有可以获得的对象和收集所有不能获得的对象，也就是区分出内存中的存活对象和死亡对象，然后GC会释放掉死亡对象所占用的内存空间
//    标记阶段：从根开始遍历，对从根对象可以访问到的对象都打上一个标识
//    清除阶段：从堆内存从头到尾进行线性遍历，如果发现某个对象没有被标记为可达对象，就会被回收
// 
//  缺点：效率低、产生的空闲内存是不连续的，都是一些碎片
//    


/**
 * 3、V8 分代收集 回收机制
 *    浏览器将数据分为两种，一种是临时对象，一种是长久对象，这两种对象对应不同的回收策略，所以V8把堆分成新生代和老生代两个区域
 *    新生代存放临时对象，老生代存放长久对象。
 *    副垃圾回收器负责新生代的垃圾回收，主垃圾回收器负责老生代的垃圾回收
 * 
 *    临时对象：
 *      大部分对象在内存中存活的时间都短，比如函数内部声明的变量、块级中的变量，当函数执行完之后，就会被回收
 * 
 *    V8会把堆分为新生代和老生代，新生代存放的是生存时间短的对象，老生代存放的生存时间久的对象
 *    新生代通常只支持1-8M的容量，老生代支持的容量就比较大了。
 *    
 *    然后V8分别使用两个不同的垃圾回收器，以便高效的实施垃圾回收：
 *      副垃圾回收器，主要负责新生代的垃圾回收；
 *      主垃圾回收器，主要负责老生代的垃圾回收
 * 
 *    不管是什么类型的垃圾回收器，都有一套共同的执行流程：
 *      第一步是标记空间中的活动对象和非活动对象，非活动对象指的就是可以进行垃圾回收的对象；
 *      第二步是回收非活动对象所占据的内存，其实就是在所有标记完成之后，统一清理内存中所有被标记为可回收的对象；
 *      第三步是内存整理，因为频繁回收对象，导致内存中存在大量不连续空间，也就是内存碎片，需要整理一下这些内存碎片
 *      
 *    新生代垃圾回收：
 *      采用Scavenge算法来处理，把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。
 *      新加入的对象存放到对象区域，当对象区域被写满时，需要执行一次垃圾清理操作。
 * 
 *      在回收过程中，先对对象区域的垃圾做标记，然后进入清理阶段，副垃圾回收器会把存活的对象复制到空闲区域中，
 *      同事还会整理排序，完成内存整理操作，复制后的空闲区域就没有内存碎片了
 * 
 *      完成复制后，对象区域与空闲区域进行角色反转，也就是原来的对象区域变为空闲区域，原来的空闲区域变为了对象区域，
 *      这样就完成了垃圾对象的回收操作
 * 
 *      为了执行效率，一般新生区的空间设置得都比较小，所以很容易导致存活的对象铺满整个区域，为了解决这个问题，JS引擎采用了
 *      对象晋升策略，也就是经过两个垃圾回收依然还存活的对象，会被移动到老生区中。
 * 
 *   老生代垃圾回收：
 *      采用标记-清除算法处理，从根元素开始标记，其实也就是遍历调用栈，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素
 *      就是垃圾数据，标记完之后就要清理，清理的过程是删除标记数据，
 * 
 *      清除算法后，会产生大量不连续的内存碎片，会导致大对象无法分配到足够的连续内存，又产生标记-清除算法，让所有存活的对象向一端移动，
 *      从而让存活对象占用连续的内存块
 * 
 * 内存泄漏的原因：
 *   缓存；
 *   队列消费不及时；
 *   全局变量；
 *   计时器引用没有清除；
 *   闭包；
 *   事件监听；
 * 
 * 内存泄漏的识别方法：
 *   使用Chrome任务管理器实时监视内存使用； 
 *   使用Chrome时间轴记录可视化内存泄漏；
 *   使用堆快照发现已分离DOM树的内存泄漏；
 *   按函数调查内存分配；
 *   
 * 避免内存泄漏的方法：
 *   少用全局变量，避免以外产生全局变量；
 *   使用闭包要及时注意，有DOM元素的引用要及时清理；
 *   计时器里的回调没用的时候要记得销毁；
 *   为了避免疏忽导致的遗忘，使用WeakSet和WeakMap结构，他们对于值的引用都是不计入垃圾回收机制的，表示是弱引用
 */
var wm = new WeakMap()
var ele = document.getElementById('example')

wm.set(ele, 'some information')
ws.get(ele) // 这种情况下，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放；WeakMap保存的这个键值对，也会自动消失

// 基本上，要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用WeakMap