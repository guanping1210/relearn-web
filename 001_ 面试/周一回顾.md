#### 1、promise

1、使用方法
2、内部原理

#### 2、模块化：commonjs AMD CMD UMD ESModule

1、每种模块化出现的原因
2、对比优缺点和使用场景

#### 3、DOM 相关：事件流程、Ajax、BOM

1、事件模型
2、addEventListener, 第三个参数 --> 为什么不在捕获阶段注册
3、target、currentTart
4、事件代理 --> React 合成事件
5、通用的事件注册封装 --> 兼容多个浏览器 addEventListener 和 touch
6、自定义 event emitter
7、ajax --> 用 promise 封装一个通用的 fetch
7.1 status 码
7.2 readyStatus 码
7.3 content-type 格式区别
8、同源策略(域名、协议、端口号都相同)、跨域
jsonp
CORS
nginx 代理
node 中间件
iframe
postMessage
websocket
9、浏览器路由 --> 浏览器访问记录 --> 如何监听

#### 4、前端工程化

1、背景、概念
2、如何做工程化 --> 模块化、组件化、规范化、自动化
3、工程化工具：gulp webpack rollup grunt vite
4、详细说一下 webpack 后续会复习到

#### 5、ES6 --> 主要说一下新特性

1、let/const --> 出现的背景：作用域、变量提升，导致 bug
2、面向对象 --> POP、OOP 类比
2.1 特性：继承、封装、多态
2.2 js 中的继承方式 --> 构造函数、class
3、构造函数和原型
4、继承的多种方式
构造函数:
原型继承：子类 prototype = 父类实例 （原型链）
构造函数继承：子类内部 this 指向父类实例（是因为 this 增强了作用域范围吗？）
实例继承：子类内部返回父类的实例
组合继承：将构造函数继承和原型继承结合起来
class:
extends 继承
5、new 关键字的过程 --> 返回的是个对象，这个对象叫实例 --> 内部要实现继承父类属性的那一些逻辑
6、数组常用的方法，以及如何模拟实现数组的常用方法
7、Object.defineProperty 定义对象属性和修改属性配置
value
writable
enumerable --> 能被 for in 遍历到
configable --> 能否删除重置
8、函数：定义方式、this、箭头函数
9、作用域、作用域链、上下文、this
10、严格模式
12、闭包 --> 延伸了变量的作用范围
13、递归 --> 自身调用自身 --> 尾递归 --> 斐波拉切数列：后一个数是前两个数之和（优化）
14、拷贝：深拷贝(新开辟内存)、浅拷贝(拷贝内存地址)
15、set、weakSet、map、weakMap
16、迭代器和生成器

#### 浏览器面试题汇总

1、页面从输入 url 到渲染到屏幕上的过程：以下是详细的需要涉及到的点
dns 解析的具体过程
tcp/ip 三次握手的具体过程
2、浏览器缓存：强缓存、协商缓存，画出缓存流程图
强缓存：expires + cache-chrotl
协商缓存 304: etag + if-none-match(比对资源标识), last-modified-since + if-modified-since(比对资源更新时间)
3、http 相关的知识
发展历史；
每个版本的对比；
三次握手机制；
四次挥手机制；
为什么一定要四次挥手 --> 防止丢包
4、event loop --> js 是单线程的(明天重点复习)

#### webpack 面试题

1、基础配置
entry
output: publicPath(转换相对路径)、filename、path(存放的路径)、chunkFilename(非入口文件的名称)
module
plugin
mode
2、html 自动替换：html-webpack-plugin clean-webpack-plugin
3、处理 css: style-loader css-loader sass-loader less-loader
处理 css 文件 -> 内联加载 ->
如何抽离为单独的文件(mini-css-extract-plugin)) ->
css 兼容性(postcss-loader + postcss-preset-env) ->
如何压缩 css(optimize-css-asset-webpack-plugin)
4、处理 js 资源： babel-loader(处理兼容性)
babel/preset-env(处理基本) -> babel/prolyfill(处理全部) -> corejs(按需加载)
5、处理图片
非 html 中的图片：url-loader
html 中的图片：html-loader, 使用这个需要将 url-loader 中的 esModule 关闭
字体资源：file-loader

#### webpack 性能优化

1、本地开发环境：
HRM
source-map

2、线上生产环境
oneOf
babel 缓存：cacheDirectory
资源缓存：hash | chunkhash | contenthash
tree-shaking: 原理是 esModule 是可静态分析的，因为 es6 模块的依赖关系是确定的
code split: webpack.optimization 实现，将大 chunk 分为不同小 chunk
懒加载：import
预加载：import prefetch
PWA 离线访问:
多进程打包：thread-loader
externals: 被指定的包可以 CDN 引入
DLL: 将第三方库独立打包，一般只打包一次即可 webpack.DllPlugin + manifset.json

#### webpack 常见问题

1、module、thunk、bundle 的区别
2、hash、thunkhash、contenthash 的区别
3、tree-shaking 原理：esModule + uglify
4、实现 thunk 分包：optimization.splitThunks
5、第三方独立打包：webpack.DllPlugin(生成映射文件) + webpack.DllReferencePlugin(引入映射文件，告诉 webpack 不打包与映射文件有关的东西)
6、loader 和 plugin 的区别
7、如何自定义 loader：loader 是个函数，接收 content 和 option
8、如何自定义 plugin：plugin 是个类，内部有个 call 函数, 接收的 compiler 对象，绑定一个事件钩子
9、webpack 打包流程
1、读取配置信息：配置文件+sell -> 配置参数
2、初始化 compiler 对象，加载插件，执行 run 函数开始执行编译
3、根据入口配置得到所有的入口文件
4、递归编译模块文件(loader 编译源码 + 转为 ast)
5、完成编译后，能够得到模块内容和依赖关系
6、组装 thunk --> 最后修改内容的机会
7、根据配置的输出路径和文件名，把文件内容写入到系统中
10、compiler 和 compilation: 都是 tapable 构造出来的实例
11、webpack 核心 tapable: 提供了事件流执行机制
12、压缩代码：terser uglify
13、webpack HRM 热更新原理

#### react

1、对 react 的理解
2、双缓存技术
3、为什么选用 JSX(类比模板、模板字符串)
4、babel 如何实现 jsx 到 js 的编译的（源码 -> ast -> createElement）
5、类组件、函数组件的区别(主要分析是 16 以前的：state、this、生命周期)
6、refs 是干什么的，有几种使用方式（回调函数、字符串、useRef、）
7、HOC 高阶组件（class 组件的逻辑复用， 接收一个组件，返回一个新的组件、redux.connect）
8、class 组件中要调用 super 的作用
9、为什么不能直接更新 state(render 结果、设计、性能优化 shouleComponentUpdate)
10、生命周期有哪些阶段？具体有哪些？
--- 初始化阶段 挂载阶段 更新阶段 卸载阶段 错误处理阶段
11、列举出 react 的生命周期
12、你对 hooks 如何看(背景、优缺点)
13、fiber 架构(背景、优缺点、中断与恢复)
14、react 渲染流程(render、setState)
15、性能优化(class.shouldComponentUpdate PureComponent + React.memo)
16、error boundary(生命周期函数、优缺点、捕获范围)
17、lazy suspense(支持范围)

#### redux

#### react-router

#### flex、grid

#### restful

#### typescript

#### 项目准备

##### 1、封装自定义 hooks: useFetch、useDrag、useTable

##### 2、抽象表单组件，把组件的增删查改，抽成一套(封装 PageList + customTable) --> 达到一个页面，传递

-- 整个项目的页面结构大致都一样，包含新增项目、修改项目、删除项目；新增和修改项目是个弹窗
-- 整个页面结构封装为 PageList 组件，外层组件传入 table 的 columns 属性和弹窗对应的 formItems 属性，就能够变为一个新的，附带增删查改功能的完整页面（columns 和 forItem 是有关联关系的）
-- pageList 内部：

- - 1、规范用同一个 URL，采取不同的请求方式表示新增、修改和删除，这样就很方便了

- - 2、读取 columns，生成表单信息，使用的是 CustomTable
  - CustomTable 内部，包含勾选、翻页、请求数据等功能

- - 3、读取 formItems，动态生成可编辑区域,封装的 PageForm
  - PageForm，使用的是 React.createElement 来创建新的表单项目，例如 input、radio、select、Date、TreeSelect 这些组件
  - 每个小组件，用 Form.Item 包裹起来，然后接收配置，例如初始值啊、校验方式、disabled、required、label 显示的，和传递的值 name 这些
  - 外面有传递 submit 函数就用外面的。如果没有，则内部根据实例 ID 是否存在，决定是 PUT 还是 POST 的请求方式，分别表示修改还是删除
  - 区分是新增还是修改：用一个变量来存储修改的实例的 ID，有 ID 就是修改呗
  - Form.onFinish, 实现 submit 提交动作，那么函数内部就自动能够实现表单各项值的获取
  - 部分表单有层级关联关系，那么就在 onValueChange 的地方监控值的变化，当发下有层级变化的，需要重置一些值，用 setFieldsValue 来实现
  - 对于部分像下拉框这种数据，需要独立请求接口，外面传递一个 server 服务进去即可，与需要使用的 column 挂钩

- - 4、配置搜索条件
  - 通常是通过自定义搜索条件，传递的格式与 column 差不多， PageContainer 内部自行处理（通过 createElement 动态创建节点）

##### 3、文件批量上传、大文件分片上传(ftp、本地文件)

-- FileReader 实例化
-- reader.readAsArrayBuffer 读取文件
-- File.slice 截取文件
-- promise.all 并行上传
-- spark-md5: 文件的唯一识别码
-- FormData： 上传格式
-- reader.readAsText：读取二进制为字符串

1、获取上传的文件信息，存为数组
2、对数组中的每个文件使用自定义封装的类实例化一下，使得文件的解析、上传方法绑定到实例上
3、使用 fileReader 分析文件、slice 切割文件、promise.all 批量上传文件
4、websocket 通知进度

##### 4、编辑器 code-mirror、react-ace、braft-editor

- code-mirror 体量大，用于语言编写
- react-ace 轻量，用于语言编写，js、python 等
- braft-editor 富文本编辑器
  - 工具栏：新增自定义工具条 -- 动态参数、中英文替换
  - 邮件模板：写的是邮件模板，添加动态参数和中英文替换 --> 就是后面在编写邮件时选择模板，模板中的一些自定义内容会替换
    - 中英文如何批量替换：加锁 -> 中英文是成对儿出现的，选了中文之后中文就被加锁，不能再选了。此时必须把对应的英文选了之后，才能继续选。。反正就是中英文，必须成对儿
  - 编写邮件：使用邮件模板，对设置的动态参数和中英文替换，会被替换为其他值（例如船舶的信息等）
  - 替换核心：自定义标识，只能通过 a 标签的 href 保存进去，因为编辑器内部自有一套逻辑的，保留下来的，只能是 href 属性
  - 读取到自定义的标识符号的时候，再去找到替换

##### 5、单例模式封装 websocket，心跳检测+重联机制

###### 6、封装 echarts 组件库

###### 7、编写自定义工具：把一个项目打包的部分文件，上传给另一个 git 项目

###### 8、项目脚手架升级：以前是 jenkins 配置，现在是选分支配置

###### 9、grid 布局

###### 10、整个大数据产品：数据网关 - 数据地图 - 数据实验室 - 数据可视化 - 数据质量
