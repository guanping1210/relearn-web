#### 1、promise
#### 2、模块化：commonjs AMD CMD UMD ESModule
#### 3、DOM相关：事件流程、Ajax、BOM
  1、事件模型
  2、addEventListener, 第三个参数 --> 为什么不在捕获阶段注册
  3、target、currentTart
  4、事件代理 --> React合成事件
  5、通用的事件注册封装 --> 兼容多个浏览器addEventListener和touch
  6、自定义event emitter
  7、ajax --> 用promise封装一个通用的fetch
    7.1 status 码
    7.2 readyStatus 码
    7.3 content-type 格式区别
  8、同源策略(域名、协议、端口号都相同)、跨域
    jsonp
    CORS
    nginx代理
    node中间件
    iframe
    postMessage
    websocket
  9、浏览器路由 --> 浏览器访问记录 --> 如何监听
#### 4、前端工程化
  1、背景、概念
  2、如何做工程化 --> 模块化、组件化、规范化、自动化
  3、工程化工具：gulp webpack rollup grunt vite
  4、详细说一下webpack 后续会复习到

#### 5、ES6 --> 主要说一下新特性
  1、let/const --> 出现的背景：作用域、变量提升，导致bug
  2、面向对象 --> POP、OOP类比
      2.1 特性：继承、封装、多态
      2.2 js中的继承方式 --> 构造函数、class
  3、构造函数和原型
  4、继承的多种方式
      构造函数:
        原型继承：子类prototype = 父类实例 （原型链）
        构造函数继承：子类内部this指向父类实例（是因为this增强了作用域范围吗？）
        实例继承：子类内部返回父类的实例
        组合继承：将构造函数继承和原型继承结合起来
      class:
        extends继承
  5、new关键字的过程 --> 返回的是个对象，这个对象叫实例 --> 内部要实现继承父类属性的那一些逻辑
  6、数组常用的方法，以及如何模拟实现数组的常用方法
  7、Object.defineProperty 定义对象属性和修改属性配置
      value
      writable
      enumerable --> 能被for in 遍历到
      configable --> 能否删除重置
  8、函数：定义方式、this、箭头函数
  9、作用域、作用域链、上下文、this
  10、严格模式
  12、闭包 --> 延伸了变量的作用范围
  13、递归 --> 自身调用自身 --> 尾递归 --> 斐波拉切数列：后一个数是前两个数之和（优化）
  14、拷贝：深拷贝(新开辟内存)、浅拷贝(拷贝内存地址)
  15、set、weakSet、map、weakMap
  16、迭代器和生成器

#### 浏览器面试题汇总
  1、页面从输入url到渲染到屏幕上的过程：以下是详细的需要涉及到的点
      dns解析的具体过程
      tcp/ip三次握手的具体过程
  2、浏览器缓存：强缓存、协商缓存，画出缓存流程图
      强缓存：expires + cache-chrotl
      协商缓存304: etag + if-none-match(比对资源标识), last-modified-since + if-modified-since(比对资源更新时间)
  3、http相关的知识
      发展历史；
      每个版本的对比；
      三次握手机制；
      四次挥手机制；
      为什么一定要四次挥手 --> 防止丢包
  4、event loop --> js是单线程的(明天重点复习)

#### webpack面试题
  1、基础配置
      entry
      output: publicPath(转换相对路径)、filename、path(存放的路径)、chunkFilename(非入口文件的名称)
      module
      plugin
      mode
  2、html自动替换：html-webpack-plugin clean-webpack-plugin
  3、处理css: style-loader css-loader sass-loader less-loader
      处理css文件 -> 内联加载 -> 
      如何抽离为单独的文件(mini-css-extract-plugin)) -> 
      css兼容性(postcss-loader + postcss-preset-env) ->
      如何压缩css(optimize-css-asset-webpack-plugin)
  4、处理js资源： babel-loader(处理兼容性)
      babel/preset-env(处理基本) -> babel/prolyfill(处理全部) -> corejs(按需加载)
  5、处理图片
      非html中的图片：url-loader
      html中的图片：html-loader, 使用这个需要将url-loader中的esModule关闭
      字体资源：file-loader

#### webpack性能优化
  1、本地开发环境：
      HRM
      source-map

  2、线上生产环境
      oneOf
      babel缓存：cacheDirectory
      资源缓存：hash | chunkhash | contenthash
      tree-shaking: 原理是esModule是可静态分析的，因为es6模块的依赖关系是确定的
      code split: webpack.optimization实现，将大chunk分为不同小chunk
      懒加载：import
      预加载：import prefetch
      PWA离线访问:
      多进程打包：thread-loader
      externals: 被指定的包可以CDN引入
      DLL: 将第三方库独立打包，一般只打包一次即可 webpack.DllPlugin + manifset.json

#### webpack常见问题
  1、module、thunk、bundle的区别
  2、hash、thunkhash、contenthash的区别
  3、tree-shaking原理：esModule + uglify
  4、实现thunk分包：optimization.splitThunks
  5、第三方独立打包：webpack.DllPlugin(生成映射文件) + webpack.DllReferencePlugin(引入映射文件，告诉webpack不打包与映射文件有关的东西)
  6、loader和plugin的区别
  7、如何自定义loader：loader是个函数，接收content和option
  8、如何自定义plugin：plugin是个类，内部有个call函数, 接收的compiler对象，绑定一个事件钩子
  9、webpack打包流程
      1、读取配置信息：配置文件+sell -> 配置参数
      2、初始化compiler对象，加载插件，执行run函数开始执行编译
      3、根据入口配置得到所有的入口文件
      4、递归编译模块文件(loader编译源码 + 转为ast)
      5、完成编译后，能够得到模块内容和依赖关系
      6、组装thunk --> 最后修改内容的机会
      7、根据配置的输出路径和文件名，把文件内容写入到系统中
  10、compiler和compilation: 都是tapable构造出来的实例
  11、webpack核心tapable: 提供了事件流执行机制
  12、压缩代码：terser uglify
  13、webpack HRM热更新原理

#### react

#### redux

#### react-router

#### flex、grid

#### restful

#### typescript

#### 项目准备
  1、封装自定义hooks: useFetch、useDrag
  2、抽象表单组件，把组件的增删查改，抽成一套
  3、文件批量上传、大文件分片上传
  4、编辑器code-mirror、react-ace、braft
  5、单例模式封装websocket，心跳检测+重联机制
  6、封装echarts组件库
  7、编写自定义工具：把一个项目打包的部分文件，上传给另一个git项目
  8、项目脚手架升级：以前是jenkins配置，现在是选分支配置
  9、整个大数据产品：数据网关 - 数据地图 - 数据实验室 - 数据可视化 - 数据质量
  10、





