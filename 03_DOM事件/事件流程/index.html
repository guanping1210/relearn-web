<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <h3>1、浏览器事件模型</h3>
  <div id="root">
    <div id="container">
      <div id="touch">touch me</div>
    </div>
  </div>

  <h3>2、addEventListener注册阶段</h3>
  <div id="bubble-root">
      <div id="bubble-container">
        <div id="bubble-touch">bubble touch me</div>
      </div>
    </div>

    <h3>3、target与currentTarget</h3>
  <div id="target">
    <div id="current-target">
      current target
      <span>121212</span>
    </div>
  </div>

  <h3>4、事件代理：冒泡</h3>
  <div id="agent">
    <li>111</li>
    <li>222</li>
    <li>333</li>
  </div>

  <h3>5、不会冒泡的特殊事件</h3>
  <div id="special">
    <span id="enter">enter</span>
    <span id="over">over</span>
  </div>

  <h3>6、阻止冒泡</h3>
  <div id="stop">
    <span>hello</span>
    <span>world</span>
  </div>

  <script>
    /*
     * 浏览器事件模型：
     * 捕获 -> 注册 ->  冒泡
    */
    function clickMe(val) {
      console.log(val)
    }

    /**
     * 1、
     * 通过addEventListener注册点击事件
     * 手动点击touch，会依次打印：touch -> container -> root
     * 说明：事件默认是在冒泡阶段注册的，所以打印是从内到外
    */
    document.getElementById('touch').addEventListener('click', () => {
      clickMe('touch')
    })

    document.getElementById('container').addEventListener('click', () => {
      clickMe('container')
    })

    document.getElementById('root').addEventListener('click', () => {
      clickMe('root')
    })

    /**
     * 2、
     * addEventListener(事件类型，事件，是否在捕获阶段注册)
     * 第三个参数默认为false
     * 如果是在捕获阶段注册，那么打印的结果会是从外到内打印
     * bubble-root -> bubble-container -> bubble-touch
    */
    document.getElementById('bubble-touch').addEventListener('click', () => {
      clickMe('bubble-touch')
    }, true)

    document.getElementById('bubble-container').addEventListener('click', () => {
      clickMe('bubble-container')
    }, true)

    document.getElementById('bubble-root').addEventListener('click', () => {
      clickMe('bubble-root')
    }, true)

    /**
     * 3、
     * removeListener, 移除事件，需要对应的事件类型、事件名，以及注册阶段，
     * 才能正确的移除一个事件
    */

    /**
     * target: 当前触发的元素，也就是当前点击的元素，是会变化的 
     * currentTarget: 绑定事件的元素,在整个事件流中是不变的
    */
   document.getElementById('target').addEventListener('click', e => {
     console.log(e.target, e.currentTarget)
   })

   /**
    * 4、
    * 事件代理：核心是通过冒泡来实现的
   */
  document.getElementById('agent').addEventListener('click', e => {
    console.log(e.target, e.currentTarget)
  })

   /**
    * 5、
    * Mouseover与Mouseenter的区别：有的事件是不会冒泡的
   */
  document.getElementById('special').addEventListener('mouseover', e => {
    console.log('over', e.target, e.currentTarget)
  })

  document.getElementById('special').addEventListener('mouseenter', e => {
    console.log('enter', e.target, e.currentTarget)
  })

  /**
   * 6、阻止冒泡 和 捕获 和 默认事件
   * e.stopPropation()
   * e.stopImmediatePropagation()
   * e.preventDefault()
   * e.defaultPrevent()
   * e.cancelBubble
   * return false
  */

  /**
   * 7、
   * 通用的事件注册和移除的函数封装
   * 主要是addEventListener和touch
  */

  /**
   * 8、
   * 自定义事件：new Event('事件名字')
   * 
  */

  /**
   * 9、css对事件的影响
   * pointer-events
   * touch-actions
  */
  </script>
</body>
</html>